name: Build Linux AppImage

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
    tags:
      - 'v*'  # Also run when a tag is pushed that starts with 'v'

permissions:
  contents: write
  packages: read
  
jobs:
  build-linux:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      
      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y fuse libfuse2 imagemagick
          wget -O appimagetool "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
          chmod +x appimagetool
      
      - name: Create virtual environment and install dependencies
        run: |
          uv venv
          source .venv/bin/activate
          uv pip install -e .
          
          # Install specific PyInstaller version compatible with Python 3.13
          uv pip install "pyinstaller>=6.1.0" toml
          
          # Create necessary directories
          mkdir -p docs db
      
      - name: Extract version from pyproject.toml and verify environment
        id: get_version
        run: |
          source .venv/bin/activate
          VERSION=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Version: $VERSION"
          
          # Debug: Check current git ref
          echo "Current GitHub ref: $GITHUB_REF"
          
          # Verify Python configuration and available standard libraries
          echo "Python version information:"
          python --version
          
          echo "Checking critical modules availability:"
          python -c "import glob; print('glob module is available')"
          python -c "import pathlib; print('pathlib module is available')"
          python -c "import pydantic; print(f'pydantic version: {pydantic.__version__}')"
          python -c "import PyInstaller; print(f'PyInstaller version: {PyInstaller.__version__}')"
          
          # Debug: Show the contents of the prompts directory
          echo "Contents of prompts directory:"
          ls -la prompts/
      
      - name: Create PyInstaller spec file
        run: |
          source .venv/bin/activate
          
          cat > dv.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          import sys
          import glob
          import os
          from PyInstaller.utils.hooks import collect_all, copy_metadata

          block_cipher = None
          
          # Get the absolute path to the directories
          base_dir = os.path.abspath(os.path.dirname(__file__))
          prompts_dir = os.path.join(base_dir, 'prompts')
          docs_dir = os.path.join(base_dir, 'docs')
          db_dir = os.path.join(base_dir, 'db')
          
          # Ensure the docs and db directories exist
          for d in [docs_dir, db_dir]:
              if not os.path.exists(d):
                  os.makedirs(d)
          
          # Print debugging info
          print(f"Prompts directory: {prompts_dir}")
          print(f"Contents of prompts directory: {os.listdir(prompts_dir)}")
          
          # Collect pydantic with all its dependencies
          pydantic_datas, pydantic_binaries, pydantic_hiddenimports = collect_all('pydantic')
          langchain_datas, langchain_binaries, langchain_hiddenimports = collect_all('langchain_ollama')
          langchain_core_datas, langchain_core_binaries, langchain_core_hiddenimports = collect_all('langchain_core')
          
          # Add standard library modules that might be missed
          std_lib_imports = ['glob', 'pathlib', 'collections', 'collections.abc', 'os', 're', 'sys', 
                             'sqlite3', 'datetime', 'logging', 'functools', 'typing']

          # Define datas with explicit paths
          datas = [
              (prompts_dir, 'prompts'),
              (docs_dir, 'docs'),
              (db_dir, 'db'),
          ]
          datas.extend(pydantic_datas)
          datas.extend(langchain_datas)
          datas.extend(langchain_core_datas)
          
          a = Analysis(
              ['src/dv/main.py'],
              pathex=[base_dir],
              binaries=[*pydantic_binaries, *langchain_binaries, *langchain_core_binaries],
              datas=datas,
              hiddenimports=[
                  *std_lib_imports,
                  *pydantic_hiddenimports,
                  *langchain_hiddenimports,
                  *langchain_core_hiddenimports,
                  'pydantic.deprecated.decorator',
                  'pydantic.deprecated',
                  'pydantic._internal._model_construction',
                  'pydantic.version',
                  'langchain_community.vectorstores',
                  'langchain_community.embeddings',
                  'numpy',
                  'ollama',
              ],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.zipfiles,
              a.datas,
              [],
              name='dv-${{ env.VERSION }}-linux',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=True,
              disable_windowed_traceback=False,
              argv_emulation=False,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
          )
          EOF

      - name: Build with PyInstaller
        run: |
          source .venv/bin/activate
          # Build with debug log level and clean build directory
          python -m PyInstaller --clean --log-level DEBUG dv.spec
          
          # Check if prompts directory was included in the build
          echo "Checking for prompts directory in dist:"
          find dist -name "prompts" -type d || echo "prompts directory not found in dist"
      
      - name: Create runtime configuration file
        run: |
          # Create a .env file to set environment variables for the standalone executable
          cat > runtime_config.py << EOF
          import os
          import sys

          # Get the directory where the executable is located
          if getattr(sys, 'frozen', False):
              # We're running in a PyInstaller bundle
              base_dir = sys._MEIPASS
          else:
              # We're running in a normal Python environment
              base_dir = os.path.dirname(os.path.abspath(__file__))

          # Set critical environment variables for the app to find its resources
          os.environ['PROMPTS_DIR'] = os.path.join(base_dir, 'prompts')
          os.environ['DOCS_DIR'] = os.path.join(base_dir, 'docs')
          os.environ['SQLITE_DB_PATH'] = os.path.join(base_dir, 'db', 'books.db')

          # Debug info
          print(f"Base directory: {base_dir}")
          print(f"Prompts directory: {os.environ['PROMPTS_DIR']}")
          print(f"Docs directory: {os.environ['DOCS_DIR']}")
          print(f"SQLite DB path: {os.environ['SQLITE_DB_PATH']}")
          
          # Check if prompts directory exists and has files
          if os.path.exists(os.environ['PROMPTS_DIR']):
              print(f"Prompts directory exists and contains: {os.listdir(os.environ['PROMPTS_DIR'])}")
          else:
              print(f"WARNING: Prompts directory does not exist")
          EOF
          
          # Ensure it gets included with the source files for PyInstaller to use
          cp runtime_config.py src/dv/
      
      - name: Patch main.py to use runtime_config
        run: |
          # Add runtime_config import to main.py to ensure proper paths
          sed -i '1s/^/import runtime_config  # Configure environment paths before other imports\n/' src/dv/main.py
          
          # Rebuild with patched main.py
          source .venv/bin/activate
          python -m PyInstaller --clean --log-level DEBUG dv.spec
      
      - name: Verify built binary
        run: |
          # Check if binary was created successfully
          if [ ! -f "dist/dv-${{ env.VERSION }}-linux" ]; then
            echo "ERROR: PyInstaller failed to create the binary!"
            exit 1
          fi
          
          # Check some basic properties of the binary
          file "dist/dv-${{ env.VERSION }}-linux"
          
          # Run ldd to check library dependencies
          ldd "dist/dv-${{ env.VERSION }}-linux" || true
          
          # Check contents of the binary
          echo "Checking for prompts directory in binary:"
          strings "dist/dv-${{ env.VERSION }}-linux" | grep -i prompts
          
      - name: Create AppDir structure
        run: |
          mkdir -p AppDir/usr/bin
          mkdir -p AppDir/usr/share/applications
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          mkdir -p AppDir/usr/share/dv
          mkdir -p AppDir/usr/share/dv/db
          mkdir -p AppDir/usr/share/dv/docs
          mkdir -p AppDir/usr/share/dv/prompts
          
          # Copy the binary
          cp dist/dv-${{ env.VERSION }}-linux AppDir/usr/bin/dv
          chmod +x AppDir/usr/bin/dv
          
          # Copy the existing prompts directory content
          cp -r prompts/* AppDir/usr/share/dv/prompts/
          
          # List copied prompts for verification
          echo "Copied prompts to AppDir:"
          ls -la AppDir/usr/share/dv/prompts/
          
          # Create desktop file
          cat > AppDir/usr/share/applications/dv.desktop << EOF
          [Desktop Entry]
          Name=dv
          Comment=Q&A app for easy information retrieval from documents
          Exec=dv
          Icon=dv
          Terminal=false
          Type=Application
          Categories=Utility;Education;Office;
          EOF
          
          # Create AppRun file (this is critical for AppImage functionality)
          cat > AppDir/AppRun << EOF
          #!/bin/bash
          SELF=\$(readlink -f "\$0")
          HERE=\${SELF%/*}
          
          # Set up environment variables
          export PATH="\${HERE}/usr/bin:\${PATH}"
          
          # Set environment variables for the application to find its resources
          # These override any built-in paths in the PyInstaller bundle
          export PROMPTS_DIR="\${HERE}/usr/share/dv/prompts"
          export DOCS_DIR="\${HERE}/usr/share/dv/docs"
          export SQLITE_DB_PATH="\${HERE}/usr/share/dv/db/books.db"
          
          # Create directories if they don't exist
          mkdir -p "\${PROMPTS_DIR}" "\${DOCS_DIR}" "\${HERE}/usr/share/dv/db"
          
          # Make sure the prompts directory exists
          if [ ! -d "\${PROMPTS_DIR}" ]; then
            echo "Warning: Prompts directory not found. Creating directory structure..."
            mkdir -p "\${PROMPTS_DIR}"
            # Copy the included prompts from the PyInstaller bundle as fallback
            if [ -d "\${HERE}/usr/bin/_internal/prompts" ]; then
              cp -r "\${HERE}/usr/bin/_internal/prompts/"* "\${PROMPTS_DIR}/"
            fi
          fi
          
          # Debug info
          echo "Running dv from \${HERE}/usr/bin/dv"
          echo "PROMPTS_DIR=\${PROMPTS_DIR}"
          echo "DOCS_DIR=\${DOCS_DIR}"
          echo "SQLITE_DB_PATH=\${SQLITE_DB_PATH}"
          echo "Prompts directory contains: \$(ls -la \${PROMPTS_DIR})"
          
          # Execute the application with environment variables
          "\${HERE}/usr/bin/dv" "\$@"
          EOF
          
          # Make AppRun executable
          chmod +x AppDir/AppRun
          
          # Create a simple icon for the application
          convert -size 256x256 xc:transparent -fill blue -draw "circle 128,128 128,64" -font Arial -fill black -pointsize 24 -gravity center -annotate 0 "DV" AppDir/dv.png
          cp AppDir/dv.png AppDir/usr/share/icons/hicolor/256x256/apps/
          
          # Copy desktop file to root as required by AppImage specification
          cp AppDir/usr/share/applications/dv.desktop AppDir/dv.desktop
          
          # Copy icon to root as required by AppImage specification
          cp AppDir/dv.png AppDir/.DirIcon
      
      - name: Build AppImage
        run: |
          # Set the architecture explicitly
          ARCH=x86_64 ./appimagetool AppDir "dv-${{ env.VERSION }}-x86_64.AppImage"
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: dv-linux
          path: dv-${{ env.VERSION }}-x86_64.AppImage
          
      - name: Set release info
        id: release_info
        run: |
          # Get current date for development builds
          CURRENT_DATE=$(date +%Y%m%d-%H%M%S)
          
          # For tag-based releases
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            echo "IS_TAG=true" >> $GITHUB_ENV
            echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
            echo "RELEASE_NAME=dv ${{ env.VERSION }}" >> $GITHUB_ENV
            echo "SHOULD_RELEASE=true" >> $GITHUB_ENV
            echo "Running on tag: $GITHUB_REF, tag name: ${GITHUB_REF#refs/tags/}"
          # For pull requests
          elif [[ $GITHUB_REF == refs/pull/* ]]; then
            PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
            echo "IS_TAG=false" >> $GITHUB_ENV
            # Don't try to create a release or tag for PRs, but upload to artifacts
            echo "SHOULD_RELEASE=false" >> $GITHUB_ENV
            echo "Running on PR: $GITHUB_REF, PR number: $PR_NUMBER"
          # For push to main
          else
            echo "IS_TAG=false" >> $GITHUB_ENV
            echo "TAG_NAME=dev-${CURRENT_DATE}" >> $GITHUB_ENV
            echo "RELEASE_NAME=dv ${{ env.VERSION }} (Development Build)" >> $GITHUB_ENV
            echo "PRERELEASE=true" >> $GITHUB_ENV
            echo "SHOULD_RELEASE=true" >> $GITHUB_ENV
            echo "Running on branch: $GITHUB_REF"
          fi
      
      - name: Generate release notes
        if: env.SHOULD_RELEASE == 'true'
        run: |
          cat > release_notes.md << EOF
          # dv Q&A App Release v${{ env.VERSION }}
          
          This release provides the Linux AppImage for dv, a Q&A application for easy information retrieval from documents of interest.
          
          ## Installation
          1. Download the AppImage
          2. Make it executable: \`chmod +x dv-${{ env.VERSION }}-x86_64.AppImage\`
          3. Run it: \`./dv-${{ env.VERSION }}-x86_64.AppImage\`
          EOF
          
          if [[ $GITHUB_REF != refs/tags/* ]]; then
            cat >> release_notes.md << EOF
          
          ## Development Build
          This is an automated development build, not an official release.
          - Build triggered by: $GITHUB_REF
          - Build date: $(date)
          - Commit: $GITHUB_SHA
          EOF
          fi
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        if: env.SHOULD_RELEASE == 'true'
        with:
          files: dv-${{ env.VERSION }}-x86_64.AppImage
          name: ${{ env.RELEASE_NAME }}
          tag_name: ${{ env.TAG_NAME }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ env.PRERELEASE == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
